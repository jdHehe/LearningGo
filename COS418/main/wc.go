package main

import (
	//"fmt"
	//"github.com/jdHeHe/LearningGo/COS418/mapreduce"
	//"os"
	//"strconv"
	//"unicode"
)

// The mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents. The return value should be a slice of
// key/value pairs, each represented by a mapreduce.KeyValue.
// 输入为文件名和文件的内容
//func mapF(document string, value string) (res []mapreduce.KeyValue) {
//	// TODO: you have to write this function
//	//lines := strings.Split(value,  "\n")
//	//words_document := make([]string, 0)
//	//for _,line := range lines{
//	//	words_line := strings.Split(line, " ")
//	//	for  _,word := range words_line{
//	//		words_document = append(words_document, word)
//	//	}
//	//}
//	//for _, word := range words_document{
//	//	res = append(res, mapreduce.KeyValue{Key:word, Value:"1"})
//	//}


//	words := make([]string, 0)
//	word := ""
//	isChar := false //标志前一个字符的状态
//	for _, char := range value {
//		if unicode.IsLetter(char) == false  || char == ' '{
//			if isChar == true {
//				words = append(words, word)
//				isChar = false
//				word = ""
//			}
//			continue
//		}
//		isChar = true
//		word += string(char)
//	}
//	for _, word = range words{
//		res = append(res, mapreduce.KeyValue{Key:word, Value:"1"})
//	}
//	return
//}
//
//// The reduce function is called once for each key generated by Map, with a
//// list of that key's string value (merged across all inputs). The return value
//// should be a single output value for that key.
//func reduceF(key string, values []string) string {
//	// TODO: you also have to write this function
//	res := 0
//	for _,value := range values{
//		count, err := strconv.Atoi(value)
//		if err != nil{
//			panic(err)
//		}
//		res += count
//	}
//	return  strconv.Itoa(res)
//}
//
//// Can be run in 3 ways:
//// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)
//// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)
//// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &)
//func main() {
//	if len(os.Args) < 4 {
//		fmt.Printf("%s: see usage comments in file\n", os.Args[0])
//	} else if os.Args[1] == "master" {
//		var mr *mapreduce.Master
//		if os.Args[2] == "sequential" {
//			mr = mapreduce.Sequential("wcseq", os.Args[3:], 3, mapF, reduceF)
//		} else {
//			mr = mapreduce.Distributed("wcseq", os.Args[3:], 3, os.Args[2])
//		}
//		mr.Wait()
//	} else {
//		mapreduce.RunWorker(os.Args[2], os.Args[3], mapF, reduceF, 100)
//	}
//}
